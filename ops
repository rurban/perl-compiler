{"version":1,"ops":[{"type":1,"author":{"id":"dc64d6d260e2683565fe6e13d60cfbe9fec0fa09"},"timestamp":1426242255,"metadata":{"github-id":"MDU6SXNzdWU2MTAzMTAyNg==","github-url":"https://github.com/rurban/perl-compiler/issues/141","origin":"github"},"title":"Produced bytecodes crash Perl 5.14.2, Worked for Perl 5.10.0","message":"Original [issue 139](https://code.google.com/p/perl-compiler/issues/detail?id=139) created by rurban on 2013-10-14T23:44:54.000Z:\n\n\u003cb\u003eWhat steps will reproduce the problem?\u003c/b\u003e\n1. perl -MO=Bytecode,-H,-osamplechat samplechat.pl\n2. perl samplechat\n3. SEG FAULT\n\n\u003cb\u003eWhat is the expected output? What do you see instead?\u003c/b\u003e\n\n\u003cb\u003eWhat version of the product are you using? On what operating system?\u003c/b\u003e\n-Perl 5.10.0 works OK. Perl 5.14.2 will crash.\n-Ubuntu 12.04\n\n\u003cb\u003ePlease provide any additional information below.\u003c/b\u003e\n# Script from NET::SERVER Net-Server-2.007/examples/samplechat.pl\n# !/usr/bin/perl -w\n\n=head1 NAME\n\nsamplechat.pl - Show a basic Net::Server::Multiplex sample\n\n=head SERVER SYNOPIS\n\n```\n# To run this in background daemon mode, listening on port 2000, do:\n\nsamplechat.pl --setsid=1 --log_file=/tmp/samplechat.log --pid_file=/tmp/samplechat.pid --port=2000\n\n# To turn off the daemon, do:\n\nkill `cat /tmp/samplechat.pid`;\n```\n\n=head CLIENT SYNOPIS\n\n```\n# from a terminal type\n\ntelnet localhost 2000\n\n# you will then be in a echo server.\n```\n\n=head DESCRIPTION\n\nThis example demonstrates some of the features of Net::Server::Multiplex\n\n=cut\n\npackage SampleChatServer;\n\nuse strict;\nuse base qw(Net::Server::Multiplex);\n\n**PACKAGE**-\u0026gt;run();\nexit;\n### ----------------------------------------------------------------\n\n```\n# Demonstrate a Net::Server style hook\nsub allow_deny_hook {\n    my $self = shift;\n    my $prop = $self-\u0026gt;{server};\n    my $sock = $prop-\u0026gt;{client};\n\n    return 1 if $prop-\u0026gt;{peeraddr} =~ /^127\\./;\n    return 0;\n}\n\n\n# Another Net::Server style hook\nsub request_denied_hook {\n    print \u0026quot;Go away!\\n\u0026quot;;\n    print STDERR \u0026quot;DEBUG: Client denied!\\n\u0026quot;;\n}\n\n\n# IO::Multiplex style callback hook\nsub mux_connection {\n    my $self = shift;\n    my $mux  = shift;\n    my $fh   = shift;\n    my $peer = $self-\u0026gt;{peeraddr};\n    # Net::Server stores a connection counter in the {requests} field.\n    $self-\u0026gt;{id} = $self-\u0026gt;{net_server}-\u0026gt;{server}-\u0026gt;{requests};\n    # Keep some values that I might need while the {server}\n    # property hash still contains the current client info\n    # and stash them in my own object hash.\n    $self-\u0026gt;{peerport} = $self-\u0026gt;{net_server}-\u0026gt;{server}-\u0026gt;{peerport};\n    # Net::Server directs STDERR to the log_file\n    print STDERR \u0026quot;DEBUG: Client [$peer] (id $self-\u0026gt;{id}) just connected...\\n\u0026quot;;\n    # Notify everyone that the client arrived\n    $self-\u0026gt;broadcast($mux,\u0026quot;JOIN: (#$self-\u0026gt;{id}) from $peer\\r\\n\u0026quot;);\n    # STDOUT is tie'd to the correct IO::Multiplex handle\n    print \u0026quot;Welcome, you are number $self-\u0026gt;{id} to connect.\\r\\n\u0026quot;;\n    # Try out the timeout feature of IO::Multiplex\n    $mux-\u0026gt;set_timeout($fh, undef);\n    $mux-\u0026gt;set_timeout($fh, 20);\n    # This is my state and will be unique to this connection\n    $self-\u0026gt;{state} = \u0026quot;junior\u0026quot;;\n}\n\n\n# If this callback is ever hooked, then the mux_connection callback\n# is guaranteed to have already been run once (if defined).\nsub mux_input {\n    my $self = shift;\n    my $mux  = shift;\n    my $fh   = shift;\n    my $in_ref = shift;  # Scalar reference to the input\n    my $peer = $self-\u0026gt;{peeraddr};\n    my $id   = $self-\u0026gt;{id};\n\n    print STDERR \u0026quot;DEBUG: input from [$peer] ready for consuming.\\n\u0026quot;;\n    # Process each line in the input, leaving partial lines\n    # in the input buffer\n    while ($$in_ref =~ s/^(.*?)\\r?\\n//) {\n        next unless $1;\n        my $message = \u0026quot;[$id - $peer] $1\\r\\n\u0026quot;;\n        $self-\u0026gt;broadcast($mux, $message);\n        print \u0026quot; - sent \u0026quot;.(length $message).\u0026quot; byte message\\r\\n\u0026quot;;\n    }\n    if ($self-\u0026gt;{state} eq \u0026quot;senior\u0026quot;) {\n        $mux-\u0026gt;set_timeout($fh, undef);\n        $mux-\u0026gt;set_timeout($fh, 40);\n    }\n}\n\n\n# It is possible that this callback will be called even\n# if mux_connection or mux_input were never called.  This\n# occurs when allow_deny or allow_deny_hook fails to\n# authorize the client.  The callback object will be the\n# default listen object instead of a client unique object.\n# However, both object should contain the $self-\u0026gt;{net_server}\n# key pointing to the original Net::Server object.\nsub mux_close {\n    my $self = shift;\n    my $mux  = shift;\n    my $fh   = shift;\n    my $peer = $self-\u0026gt;{peeraddr};\n    # If mux_connection has actually been run\n    if (exists $self-\u0026gt;{id}) {\n        $self-\u0026gt;broadcast($mux,\u0026quot;LEFT: (#$self-\u0026gt;{id}) from $peer\\r\\n\u0026quot;);\n        print STDERR \u0026quot;DEBUG: Client [$peer] (id $self-\u0026gt;{id}) closed connection!\\n\u0026quot;;\n    }\n}\n\n\n# This callback will happen when the mux-\u0026gt;set_timeout expires.\nsub mux_timeout {\n    my $self = shift;\n    my $mux  = shift;\n    my $fh   = shift;\n    print STDERR \u0026quot;DEBUG: HEARTBEAT!\\n\u0026quot;;\n    if ($self-\u0026gt;{state} eq \u0026quot;junior\u0026quot;) {\n        print \u0026quot;Whoa, you must have a lot of patience.  You have been upgraded.\\r\\n\u0026quot;;\n        $self-\u0026gt;{state} = \u0026quot;senior\u0026quot;;\n    } elsif ($self-\u0026gt;{state} eq \u0026quot;senior\u0026quot;) {\n        print \u0026quot;If you don't want to talk then you should leave. *BYE*\\r\\n\u0026quot;;\n        close(STDOUT);\n    }\n    $mux-\u0026gt;set_timeout($fh, undef);\n    $mux-\u0026gt;set_timeout($fh, 40);\n}\n\n\n# Routine to send a message to all clients in a mux.\nsub broadcast {\n    my $self = shift;\n    my $mux  = shift;\n    my $msg  = shift;\n    foreach my $fh ($mux-\u0026gt;handles) {\n        # NOTE: All the client unique objects can be found at\n        # $mux-\u0026gt;{_fhs}-\u0026gt;{$fh}-\u0026gt;{object}\n        # In this example, the {id} would be\n        #   $mux-\u0026gt;{_fhs}-\u0026gt;{$fh}-\u0026gt;{object}-\u0026gt;{id}\n        print $fh $msg;\n    }\n}\n```","files":null}]}