{"version":1,"ops":[{"type":5,"author":{"id":"dc64d6d260e2683565fe6e13d60cfbe9fec0fa09"},"timestamp":1426200188,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDI1MTM3ODA0NQ=="},"added":["Type-Defect"],"removed":[]},{"type":5,"author":{"id":"dc64d6d260e2683565fe6e13d60cfbe9fec0fa09"},"timestamp":1426200188,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDI1MTM3ODA0Ng=="},"added":["OpSys-All"],"removed":[]},{"type":5,"author":{"id":"dc64d6d260e2683565fe6e13d60cfbe9fec0fa09"},"timestamp":1426200188,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDI1MTM3ODA0Nw=="},"added":["Priority-Medium"],"removed":[]},{"type":5,"author":{"id":"dc64d6d260e2683565fe6e13d60cfbe9fec0fa09"},"timestamp":1426200188,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDI1MTM3ODA0OA=="},"added":["Component-Logic"],"removed":[]},{"type":3,"author":{"id":"dc64d6d260e2683565fe6e13d60cfbe9fec0fa09"},"timestamp":1426200190,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDc4NjY4NDU5","github-url":"https://github.com/rurban/perl-compiler/issues/44#issuecomment-78668459"},"message":"Comment [#1](https://code.google.com/p/perl-compiler/issues/detail?id=42#c1) originally posted by rurban on 2010-08-29T18:44:07.000Z:\n\n# I shrinked the test case a bit. Results are unchanged.\n\nsub f1 { 1 }\nf1();\n\n# print do { 7; 2 }, \"\\n\";","files":null},{"type":3,"author":{"id":"dc64d6d260e2683565fe6e13d60cfbe9fec0fa09"},"timestamp":1426200194,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDc4NjY4NTEz","github-url":"https://github.com/rurban/perl-compiler/issues/44#issuecomment-78668513"},"message":"Comment [#2](https://code.google.com/p/perl-compiler/issues/detail?id=42#c2) originally posted by rurban on 2010-09-07T21:29:04.000Z:\n\nThe Perl stackpointer is stored inside a global variable PL_stack_sp and additionally cached inside a local variable sp. This technique is used inside Perl but also employed inside the code generated by perl-compiler.\nEach time, the perl library is called, both stack pointers need to be synchronised.\nThis is achieved by enclosing a library call with macros PUTBACK and SPAGAIN.\nPerl-compiler omits both macros for libray calls, which don't use the stack.\nThe names of these library functions are stored in %no_stack.\nBut pp_enter and pp_leave are marked erroneously. \nBoth calls don't get parameters or put return values on the stack. But pp_enter stores the current value of the global stack pointer into the context stack. pp_leave gets it back from cxstack. If stack pointers arn't synchronised, the wrong value gets stored. This wrong value is frequently read back from cxstack.\n\nThis has been fixed with r596.\nNo testcase has been added tough.","files":null},{"type":4,"author":{"id":"dc64d6d260e2683565fe6e13d60cfbe9fec0fa09"},"timestamp":1426200197,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50MjUxMzc4MTkx"},"status":2}]}